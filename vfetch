#!/bin/bash

# Colors (using tput for reliability)
RED=$(tput setaf 1)
GREEN=$(tput setaf 2)
YELLOW=$(tput setaf 3)
BLUE=$(tput setaf 4)
PURPLE=$(tput setaf 5)
CYAN=$(tput setaf 6)
NC=$(tput sgr0)

# Get terminal width for dynamic sizing
TERM_WIDTH=$(tput cols)

# Set explicit padding values
ASCII_WIDTH=45      # Width of ASCII art
RIGHT_PADDING=35    # Space between ASCII and info
LABEL_WIDTH=12      # Width of info labels

# Function to create a string of spaces
create_padding() {
    printf "%*s" "$1" ""
}

# Store the ASCII art
IFS='' read -r -d '' ASCII_ART << "EOF"
██╗   ██╗███████╗███████╗████████╗ ██████╗██╗  ██╗
██║   ██║██╔════╝██╔════╝╚══██╔══╝██╔════╝██║  ██║
██║   ██║█████╗  █████╗     ██║   ██║     ███████║
╚██╗ ██╔╝██╔══╝  ██╔══╝     ██║   ██║     ██╔══██║
 ╚████╔╝ ██║     ███████╗   ██║   ╚██████╗██║  ██║
  ╚═══╝  ╚═╝     ╚══════╝   ╚═╝    ╚═════╝╚═╝  ╚═╝
EOF

# Convert ASCII art to array
mapfile -t ascii_art <<< "$ASCII_ART"

# Get system information
os=$(sed -n 's/PRETTY_NAME="\(.*\)"/\1/p' /etc/os-release)
host=$(hostname)
kernel=$(uname -r)
uptime=$(uptime -p | sed 's/up //')
packages="$(rpm -qa | wc -l) (rpm), $(flatpak list 2>/dev/null | wc -l) (flatpak)"
shell=$(basename "$SHELL")
de="$XDG_CURRENT_DESKTOP"
IFS=':' read -r _ cpu_model < <(grep "model name" /proc/cpuinfo | head -1)
cpu_cores=$(grep -c ^processor /proc/cpuinfo)
cpu="${cpu_model# } ($cpu_cores)"

# Memory info
while read -r line; do
    case $line in
        *MemTotal:*) total=$((${line##* }/1024));;
        *MemAvailable:*) avail=$((${line##* }/1024));;
    esac
done < /proc/meminfo
used=$((total-avail))
memory="${used}MB / ${total}MB"

# GPU and other info
gpu=$(lspci | grep -i 'vga\|3d\|display' | sed 's/.*: //')
read -r _ used total used_percent _ <<< "$(df -h / | awk 'NR==2{print $3,$2,$5}')"
disk="$used/$total ($used_percent)"
if [ -d "/sys/class/power_supply/BAT0" ]; then
    bat_status=$(< /sys/class/power_supply/BAT0/status)
    bat_percent=$(< /sys/class/power_supply/BAT0/capacity)
    battery="$bat_percent% ($bat_status)"
fi
local_ip=$(hostname -I | cut -d' ' -f1)
locale="$LANG"

# Create array of formatted info lines
declare -a info_lines=(
    "${RED}OS${NC}:${GREEN} $os${NC}"
    "${RED}Host${NC}:${CYAN} $host${NC}"
    "${RED}Kernel${NC}:${PURPLE} $kernel${NC}"
    "${RED}Uptime${NC}:${YELLOW} $uptime${NC}"
    "${RED}Packages${NC}:${PURPLE} $packages${NC}"
    "${RED}Shell${NC}:${CYAN} $shell${NC}"
    "${RED}DE${NC}:${BLUE} $de${NC}"
    "${RED}CPU${NC}:${GREEN} $cpu${NC}"
    "${RED}Memory${NC}:${BLUE} $memory${NC}"
    "${RED}GPU${NC}:${PURPLE} $gpu${NC}"
    "${RED}Disk${NC}:${RED} $disk${NC}"
    "${RED}Battery${NC}:${RED} $battery${NC}"
    "${RED}Local IP${NC}:${CYAN} $local_ip${NC}"
    "${RED}Locale${NC}:${CYAN} $locale${NC}"
)

# Print everything with proper padding
echo # Add top padding

# Get the maximum number of lines
max_lines=$(( ${#ascii_art[@]} > ${#info_lines[@]} ? ${#ascii_art[@]} : ${#info_lines[@]} ))

# Print ASCII and info side by side with fixed padding
for ((i = 0; i < max_lines; i++)); do
    # Print ASCII art (in red) if available, otherwise empty space
    if ((i < ${#ascii_art[@]})); then
        printf "${RED}%s" "${ascii_art[i]}"
    else
        printf "%*s" "$ASCII_WIDTH" ""
    fi
    
    # Add fixed padding between ASCII and info
    printf "%*s" "$RIGHT_PADDING" ""
    
    # Print info line if available
    if ((i < ${#info_lines[@]})); then
        printf "%s" "${info_lines[i]}"
    fi
    
    printf "\n"
done

echo # Add bottom padding